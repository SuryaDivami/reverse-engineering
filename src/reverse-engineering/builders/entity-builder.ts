/* eslint-disable prettier/prettier */
import { FileBuilder } from './file-builder';
import { TableInfo, ColumnInfo, ForeignKeyInfo, EntityGenerationOptions, DatabaseDialect } from '../types/database.types';
import { TypeMapper } from '../utils/type-mapper';
import { NamingUtils } from '../utils/naming-utils';
import * as path from 'path';

export class EntityBuilder {
  constructor(
    private readonly options: EntityGenerationOptions,
    private readonly allTables: TableInfo[],
    private readonly dialect: DatabaseDialect
  ) {}

  /**
   * Generate entity class for a table
   */
  public async generateEntity(table: TableInfo): Promise<void> {
    const fileBuilder = new FileBuilder({
      outputPath: this.getEntityFilePath(table.tableName),
      overwrite: true,
      createDirectories: true
    });

    const className = NamingUtils.toSafeClassName(table.tableName);
    const imports = this.generateImports(table);
    
    // Add file header comment
    fileBuilder.addComment('Generated by reverse-engineering tool', 'line');
    fileBuilder.addEmptyLine();

    // Add imports
    imports.forEach(importStatement => {
      fileBuilder.addLine(importStatement);
    });
    fileBuilder.addEmptyLine();

    // Add table comment if available
    if (table.tableComment && this.options.includeComments) {
      fileBuilder.addComment(table.tableComment, 'block');
    }

    // Add entity decorator
    const tableDecorator = this.generateTableDecorator(table);
    fileBuilder.addLine(tableDecorator);

    // Start class
    fileBuilder.startBlock(`export class ${className}`);

    // Generate properties
    for (const column of table.columns) {
      await this.generateProperty(fileBuilder, column, table);
      fileBuilder.addEmptyLine();
    }

    // Generate relationships if enabled
    if (this.options.includeRelations) {
      await this.generateRelationships(fileBuilder, table);
    }

    // End class
    fileBuilder.endBlock();

    // Write to file
    await fileBuilder.writeToFile();
    
    console.log(`Generated entity: ${className} -> ${this.getEntityFilePath(table.tableName)}`);
  }

  private generateImports(table: TableInfo): string[] {
    const imports: string[] = [];
    const typeOrmImports = new Set(['Entity', 'Column']);
    const entityImports = new Set<string>();
    
    // Check if we need PrimaryGeneratedColumn, PrimaryColumn, or composite primary key decorators
    const primaryKeys = table.primaryKeys;
    if (primaryKeys.length === 1) {
      const pkColumn = table.columns.find(col => col.columnName === primaryKeys[0]);
      if (pkColumn?.isAutoIncrement) {
        typeOrmImports.add('PrimaryGeneratedColumn');
      } else {
        typeOrmImports.add('PrimaryColumn');
      }
    } else if (primaryKeys.length > 1) {
      typeOrmImports.add('PrimaryColumn');
    }

    // Check for relationships
    if (this.options.includeRelations && table.foreignKeys.length > 0) {
      typeOrmImports.add('ManyToOne');
      typeOrmImports.add('JoinColumn');
      
      // Add imports for referenced entities
      table.foreignKeys.forEach(fk => {
        const referencedClassName = NamingUtils.toSafeClassName(fk.referencedTableName);
        const fileName = NamingUtils.toFileName(fk.referencedTableName);
        entityImports.add(`import { ${referencedClassName} } from './${fileName}.entity';`);
      });
    }

    // Check for reverse relationships
    const reverseRelations = this.findReverseRelations(table);
    if (this.options.includeRelations && reverseRelations.length > 0) {
      typeOrmImports.add('OneToMany');
      
      // Add imports for related entities
      reverseRelations.forEach(relation => {
        const relatedClassName = NamingUtils.toSafeClassName(relation.tableName);
        const fileName = NamingUtils.toFileName(relation.tableName);
        entityImports.add(`import { ${relatedClassName} } from './${fileName}.entity';`);
      });
    }

    // Check for enum types
    const hasEnums = table.columns.some(col => col.enumValues && col.enumValues.length > 0);
    if (hasEnums) {
      // We'll generate enums inline or import them
    }

    imports.push(`import { ${Array.from(typeOrmImports).sort().join(', ')} } from 'typeorm';`);
    
    // Add entity imports
    Array.from(entityImports).sort().forEach(entityImport => {
      imports.push(entityImport);
    });
    
    return imports;
  }

  private generateTableDecorator(table: TableInfo): string {
    const nameInfo = NamingUtils.handleCompositeName(table.tableName);
    
    if (nameInfo.quoted || table.tableSchema !== 'public') {
      return `@Entity({ name: '${table.tableName}', schema: '${table.tableSchema}' })`;
    } else {
      return `@Entity('${table.tableName}')`;
    }
  }

  private async generateProperty(fileBuilder: FileBuilder, column: ColumnInfo, table: TableInfo): Promise<void> {
    const propertyName = NamingUtils.toSafePropertyName(column.columnName, this.options.namingConvention);
    const typeMapping = TypeMapper.mapType(column.dataType, this.dialect, column.isNullable);
    const isPrimaryKey = table.primaryKeys.includes(column.columnName);
    
    // Add comment if enabled
    if (column.columnComment && this.options.includeComments) {
      fileBuilder.addComment(column.columnComment);
    }

    const decorators: string[] = [];

    // Primary key decorators
    if (isPrimaryKey) {
      if (column.isAutoIncrement && table.primaryKeys.length === 1) {
        decorators.push('@PrimaryGeneratedColumn()');
      } else {
        decorators.push('@PrimaryColumn()');
      }
    } else {
      // Regular column decorator
      const columnOptions = this.generateColumnOptions(column, typeMapping);
      decorators.push(`@Column(${columnOptions})`);
    }

    // Generate property
    fileBuilder.addProperty(
      propertyName,
      typeMapping.tsType + (typeMapping.isOptional ? ' | null' : ''),
      {
        decorators,
        optional: typeMapping.isOptional,
        comment: column.columnComment && this.options.includeComments ? column.columnComment : undefined
      }
    );
  }

  private generateColumnOptions(column: ColumnInfo, typeMapping: any): string {
    const options: any = {};
    
    // Handle column name mismatch
    const propertyName = NamingUtils.toSafePropertyName(column.columnName, this.options.namingConvention);
    const nameInfo = NamingUtils.handleCompositeName(column.columnName);
    
    if (nameInfo.quoted || nameInfo.safe !== column.columnName || propertyName !== column.columnName) {
      options.name = `'${column.columnName}'`;
    }

    // Type mapping
    if (typeMapping.typeormType !== 'varchar' || typeMapping.typeormType === 'text') {
      options.type = `'${typeMapping.typeormType}'`;
    }

    // Length
    if (column.characterMaximumLength && typeMapping.typeormType === 'varchar') {
      options.length = column.characterMaximumLength;
    }

    // Precision and scale for numeric types
    if (column.numericPrecision && ['decimal', 'numeric'].includes(typeMapping.typeormType)) {
      options.precision = column.numericPrecision;
      if (column.numericScale) {
        options.scale = column.numericScale;
      }
    }

    // Nullable
    if (!column.isNullable) {
      options.nullable = false;
    }

    // Default value
    if (column.defaultValue && !column.isAutoIncrement) {
      // Parse and format default values
      const defaultVal = column.defaultValue;
      
      // Handle common default value patterns
      if (defaultVal === 'CURRENT_TIMESTAMP' || defaultVal === 'now()') {
        options.default = '() => "CURRENT_TIMESTAMP"';
      } else if (defaultVal.includes('nextval')) {
        // Skip sequence defaults as they're handled by @PrimaryGeneratedColumn
      } else if (!isNaN(Number(defaultVal))) {
        options.default = Number(defaultVal);
      } else if (defaultVal.startsWith("'") && defaultVal.endsWith("'")) {
        options.default = defaultVal;
      } else {
        options.default = `'${defaultVal}'`;
      }
    }

    // Enum values
    if (column.enumValues && column.enumValues.length > 0) {
      options.enum = `[${column.enumValues.map(val => `'${val}'`).join(', ')}]`;
    }

    // Comment
    if (column.columnComment && this.options.includeComments) {
      options.comment = `'${column.columnComment.replace(/'/g, "\\'")}'`;
    }

    // Format options object
    if (Object.keys(options).length === 0) {
      return '';
    }

    const optionStrings = Object.entries(options).map(([key, value]) => {
      if (typeof value === 'string' && (key === 'default' && value.startsWith('()'))) {
        return `${key}: ${value}`;
      }
      return `${key}: ${value}`;
    });

    return `{ ${optionStrings.join(', ')} }`;
  }

  private async generateRelationships(fileBuilder: FileBuilder, table: TableInfo): Promise<void> {
    for (const fk of table.foreignKeys) {
      await this.generateManyToOneRelation(fileBuilder, fk);
      fileBuilder.addEmptyLine();
    }

    // Generate reverse relationships (OneToMany)
    const reverseRelations = this.findReverseRelations(table);
    for (const relation of reverseRelations) {
      await this.generateOneToManyRelation(fileBuilder, relation, table);
      fileBuilder.addEmptyLine();
    }
  }

  private async generateManyToOneRelation(fileBuilder: FileBuilder, fk: ForeignKeyInfo): Promise<void> {
    const referencedTable = this.allTables.find(t => 
      t.tableName === fk.referencedTableName && t.tableSchema === fk.referencedTableSchema
    );
    
    if (!referencedTable) return;

    const referencedClassName = NamingUtils.toSafeClassName(fk.referencedTableName);
    const propertyName = NamingUtils.toRelationshipName(fk.referencedTableName, false);
    
    fileBuilder.addLine(`@ManyToOne(() => ${referencedClassName})`);
    fileBuilder.addLine(`@JoinColumn({ name: '${fk.columnName}' })`);
    fileBuilder.addProperty(
      propertyName,
      referencedClassName,
      { optional: true }
    );
  }

  private async generateOneToManyRelation(fileBuilder: FileBuilder, relation: any, table: TableInfo): Promise<void> {
    const relatedClassName = NamingUtils.toSafeClassName(relation.tableName);
    const propertyName = NamingUtils.toRelationshipName(relation.tableName, true);
    
    fileBuilder.addLine(`@OneToMany(() => ${relatedClassName}, ${relation.propertyName} => ${relation.propertyName}.${NamingUtils.toRelationshipName(table.tableName, false)})`);
    fileBuilder.addProperty(
      propertyName,
      `${relatedClassName}[]`,
      { optional: true }
    );
  }

  private findReverseRelations(table: TableInfo): any[] {
    const reverseRelations: any[] = [];
    
    for (const otherTable of this.allTables) {
      if (otherTable.tableName === table.tableName) continue;
      
      for (const fk of otherTable.foreignKeys) {
        if (fk.referencedTableName === table.tableName && fk.referencedTableSchema === table.tableSchema) {
          reverseRelations.push({
            tableName: otherTable.tableName,
            foreignKey: fk,
            propertyName: NamingUtils.toRelationshipName(otherTable.tableName, false)
          });
        }
      }
    }
    
    return reverseRelations;
  }

  private getEntityFilePath(tableName: string): string {
    const fileName = NamingUtils.toFileName(tableName);
    return path.join(this.options.outputPath, `${fileName}.entity.ts`);
  }
}
